# React Patterns (Apply Intelligently)

## Component Design Patterns

### Compound Components
Use for complex UI that needs flexible composition:
```typescript
// Modal.tsx
export const Modal = ({ children, isOpen, onClose }) => {
  if (!isOpen) return null;
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
};

Modal.Header = ({ children }) => <header className="modal-header">{children}</header>;
Modal.Body = ({ children }) => <main className="modal-body">{children}</main>;
Modal.Footer = ({ children }) => <footer className="modal-footer">{children}</footer>;
```

### Custom Hooks for Logic Reuse
Extract stateful logic into custom hooks:
```typescript
const useLocalStorage = <T>(key: string, initialValue: T) => {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error setting localStorage:', error);
    }
  };

  return [storedValue, setValue] as const;
};
```

### Render Props for Accessibility
Share accessibility state across components:
```typescript
interface FocusTrapProps {
  children: (props: { 
    focusTrapRef: React.RefObject<HTMLDivElement>;
    isActive: boolean;
  }) => React.ReactNode;
}

const FocusTrap = ({ children }: FocusTrapProps) => {
  const focusTrapRef = useRef<HTMLDivElement>(null);
  const [isActive, setIsActive] = useState(false);

  // Focus trap logic here...

  return <>{children({ focusTrapRef, isActive })}</>;
};
```

## Performance Optimization

### Memoization Strategies
Apply when dependencies are expensive to compute:
```typescript
// Expensive calculations
const ExpensiveComponent = React.memo(({ data, filters }) => {
  const filteredData = useMemo(() => {
    return data.filter(item => 
      filters.every(filter => filter.predicate(item))
    );
  }, [data, filters]);

  const sortedData = useMemo(() => {
    return [...filteredData].sort(compareFunction);
  }, [filteredData]);

  return <DataTable data={sortedData} />;
});

// Callback memoization for child components
const ParentComponent = () => {
  const [items, setItems] = useState([]);
  
  const handleItemUpdate = useCallback((id: string, updates: Partial<Item>) => {
    setItems(prev => prev.map(item => 
      item.id === id ? { ...item, ...updates } : item
    ));
  }, []);

  return (
    <div>
      {items.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onUpdate={handleItemUpdate}
        />
      ))}
    </div>
  );
};
```

### Code Splitting
Implement when bundle size approaches limits:
```typescript
// Route-based splitting
const HomePage = lazy(() => import('./pages/HomePage'));
const ProfilePage = lazy(() => import('./pages/ProfilePage'));

// Feature-based splitting
const useAdvancedFeatures = () => {
  const [feature, setFeature] = useState(null);
  
  const loadFeature = useCallback(async () => {
    const module = await import('./AdvancedFeatures');
    setFeature(module.default);
  }, []);
  
  return { feature, loadFeature };
};
```

## State Management Patterns

### Reducer for Complex State
Use when state has multiple related values:
```typescript
interface AppState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  preferences: UserPreferences;
}

type AppAction = 
  | { type: 'LOAD_START' }
  | { type: 'LOAD_SUCCESS'; payload: User }
  | { type: 'LOAD_ERROR'; payload: string }
  | { type: 'UPDATE_PREFERENCES'; payload: Partial<UserPreferences> };

const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'LOAD_START':
      return { ...state, isLoading: true, error: null };
    case 'LOAD_SUCCESS':
      return { ...state, isLoading: false, user: action.payload };
    case 'LOAD_ERROR':
      return { ...state, isLoading: false, error: action.payload };
    case 'UPDATE_PREFERENCES':
      return { 
        ...state, 
        preferences: { ...state.preferences, ...action.payload }
      };
    default:
      return state;
  }
};
```

### Context for Global State
Use for app-wide state that many components need:
```typescript
interface ThemeContextType {
  theme: 'light' | 'dark' | 'auto';
  setTheme: (theme: 'light' | 'dark' | 'auto') => void;
  isDark: boolean;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const [theme, setTheme] = useState<'light' | 'dark' | 'auto'>('auto');
  
  const isDark = useMemo(() => {
    if (theme === 'auto') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    return theme === 'dark';
  }, [theme]);

  const value = useMemo(() => ({ theme, setTheme, isDark }), [theme, isDark]);
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};
```

## Error Handling

### Error Boundaries
Implement for graceful error recovery:
```typescript
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: React.ErrorInfo;
}

class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{ fallback?: React.ComponentType<{ error: Error }> }>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({ errorInfo });
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback;
      
      if (FallbackComponent && this.state.error) {
        return <FallbackComponent error={this.state.error} />;
      }

      return (
        <div role="alert" className="error-boundary">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error?.message}</pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## When to Apply These Patterns

- **Compound Components**: When building reusable UI libraries or complex components
- **Custom Hooks**: When logic is shared between multiple components
- **Memoization**: When profiling shows expensive re-renders or calculations
- **Code Splitting**: When approaching bundle size limits (75% of budget)
- **Reducers**: When state updates involve multiple related values
- **Context**: When prop drilling becomes excessive (3+ levels)
- **Error Boundaries**: Around route components and complex features
