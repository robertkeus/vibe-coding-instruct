# API Integration Patterns (Apply Intelligently)

## REST API Patterns

### Type-Safe API Client
```typescript
// ✅ Generic API client with type safety
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface ApiError {
  error: string;
  status: number;
  details?: Record<string, string[]>;
}

type ApiResult<T> = ApiResponse<T> | ApiError;

class ApiClient {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;

  constructor(baseURL: string, defaultHeaders: Record<string, string> = {}) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...defaultHeaders,
    };
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResult<T>> {
    try {
      const url = `${this.baseURL}${endpoint}`;
      const response = await fetch(url, {
        ...options,
        headers: {
          ...this.defaultHeaders,
          ...options.headers,
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          error: data.message || 'Request failed',
          status: response.status,
          details: data.details,
        };
      }

      return {
        data,
        status: response.status,
        message: data.message,
      };
    } catch (error) {
      return {
        error: error instanceof Error ? error.message : 'Network error',
        status: 0,
      };
    }
  }

  async get<T>(endpoint: string): Promise<ApiResult<T>> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T, U = unknown>(endpoint: string, data: U): Promise<ApiResult<T>> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put<T, U = unknown>(endpoint: string, data: U): Promise<ApiResult<T>> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete<T>(endpoint: string): Promise<ApiResult<T>> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}
```

### Data Fetching Hook
```typescript
// ✅ Comprehensive data fetching hook
interface UseFetchOptions {
  enabled?: boolean;
  refetchOnWindowFocus?: boolean;
  retryCount?: number;
  retryDelay?: number;
  cacheTime?: number;
}

interface UseFetchResult<T> {
  data: T | null;
  error: string | null;
  isLoading: boolean;
  isError: boolean;
  isSuccess: boolean;
  refetch: () => Promise<void>;
}

export const useFetch = <T>(
  endpoint: string,
  options: UseFetchOptions = {}
): UseFetchResult<T> => {
  const {
    enabled = true,
    refetchOnWindowFocus = false,
    retryCount = 3,
    retryDelay = 1000,
    cacheTime = 5 * 60 * 1000, // 5 minutes
  } = options;

  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const cacheRef = useRef<Map<string, { data: T; timestamp: number }>>(new Map());
  const retryCountRef = useRef(0);

  const fetchData = useCallback(async () => {
    if (!enabled) return;

    // Check cache first
    const cached = cacheRef.current.get(endpoint);
    if (cached && Date.now() - cached.timestamp < cacheTime) {
      setData(cached.data);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const apiClient = new ApiClient(process.env.REACT_APP_API_BASE_URL || '');
      const result = await apiClient.get<T>(endpoint);

      if ('error' in result) {
        throw new Error(result.error);
      }

      setData(result.data);
      setError(null);
      retryCountRef.current = 0;

      // Cache successful result
      cacheRef.current.set(endpoint, {
        data: result.data,
        timestamp: Date.now(),
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      
      if (retryCountRef.current < retryCount) {
        retryCountRef.current++;
        setTimeout(fetchData, retryDelay * retryCountRef.current);
      } else {
        setError(errorMessage);
      }
    } finally {
      setIsLoading(false);
    }
  }, [endpoint, enabled, retryCount, retryDelay, cacheTime]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Refetch on window focus if enabled
  useEffect(() => {
    if (!refetchOnWindowFocus) return;

    const handleFocus = () => fetchData();
    window.addEventListener('focus', handleFocus);
    
    return () => window.removeEventListener('focus', handleFocus);
  }, [fetchData, refetchOnWindowFocus]);

  return {
    data,
    error,
    isLoading,
    isError: !!error,
    isSuccess: !!data && !error,
    refetch: fetchData,
  };
};
```

## GraphQL Integration

### Apollo Client Setup
```typescript
// ✅ Apollo Client with error handling and caching
import { ApolloClient, InMemoryCache, createHttpLink, from } from '@apollo/client';
import { onError } from '@apollo/client/link/error';
import { setContext } from '@apollo/client/link/context';

const httpLink = createHttpLink({
  uri: process.env.REACT_APP_GRAPHQL_ENDPOINT,
});

const authLink = setContext((_, { headers }) => {
  const token = localStorage.getItem('authToken');
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : '',
    },
  };
});

const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(`GraphQL error: Message: ${message}, Location: ${locations}, Path: ${path}`);
      
      // Announce GraphQL errors to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'assertive');
      announcement.className = 'sr-only';
      announcement.textContent = `Error: ${message}`;
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 3000);
    });
  }

  if (networkError) {
    console.error(`Network error: ${networkError}`);
    
    // Handle authentication errors
    if (networkError.statusCode === 401) {
      localStorage.removeItem('authToken');
      window.location.href = '/login';
    }
  }
});

export const apolloClient = new ApolloClient({
  link: from([errorLink, authLink, httpLink]),
  cache: new InMemoryCache({
    typePolicies: {
      Query: {
        fields: {
          // Custom cache policies
          users: {
            merge(existing = [], incoming) {
              return [...existing, ...incoming];
            },
          },
        },
      },
    },
  }),
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
    },
    query: {
      errorPolicy: 'all',
    },
  },
});
```

### GraphQL Hook Patterns
```typescript
// ✅ Type-safe GraphQL hooks
import { useQuery, useMutation, useSubscription } from '@apollo/client';
import { gql } from '@apollo/client';

// Query hook with accessibility considerations
export const useUsers = (options: { limit?: number; offset?: number } = {}) => {
  const { data, loading, error, refetch } = useQuery(GET_USERS, {
    variables: options,
    notifyOnNetworkStatusChange: true,
  });

  // Announce loading state to screen readers
  useEffect(() => {
    if (loading) {
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.className = 'sr-only';
      announcement.textContent = 'Loading users...';
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 1000);
    }
  }, [loading]);

  return {
    users: data?.users || [],
    loading,
    error,
    refetch,
  };
};

// Mutation hook with optimistic updates
export const useCreateUser = () => {
  const [createUser, { loading, error }] = useMutation(CREATE_USER, {
    update(cache, { data }) {
      if (data?.createUser) {
        cache.modify({
          fields: {
            users(existingUsers = []) {
              const newUserRef = cache.writeFragment({
                data: data.createUser,
                fragment: gql`
                  fragment NewUser on User {
                    id
                    name
                    email
                  }
                `,
              });
              return [newUserRef, ...existingUsers];
            },
          },
        });
      }
    },
    onCompleted(data) {
      // Announce success to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.className = 'sr-only';
      announcement.textContent = `User ${data.createUser.name} created successfully`;
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 2000);
    },
  });

  return { createUser, loading, error };
};
```

## Real-time Data

### WebSocket Integration
```typescript
// ✅ WebSocket hook with reconnection and accessibility
interface UseWebSocketOptions {
  onOpen?: () => void;
  onMessage?: (data: any) => void;
  onClose?: () => void;
  onError?: (error: Event) => void;
  shouldReconnect?: boolean;
  reconnectAttempts?: number;
  reconnectInterval?: number;
}

export const useWebSocket = (url: string, options: UseWebSocketOptions = {}) => {
  const {
    onOpen,
    onMessage,
    onClose,
    onError,
    shouldReconnect = true,
    reconnectAttempts = 5,
    reconnectInterval = 3000,
  } = options;

  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('disconnected');
  const [lastMessage, setLastMessage] = useState<any>(null);
  
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttemptsRef = useRef(0);

  const connect = useCallback(() => {
    if (socket?.readyState === WebSocket.OPEN) return;

    setConnectionStatus('connecting');
    const ws = new WebSocket(url);

    ws.onopen = () => {
      setConnectionStatus('connected');
      setSocket(ws);
      reconnectAttemptsRef.current = 0;
      
      // Announce connection to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.className = 'sr-only';
      announcement.textContent = 'Real-time connection established';
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 2000);
      
      onOpen?.();
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setLastMessage(data);
      onMessage?.(data);
    };

    ws.onclose = () => {
      setConnectionStatus('disconnected');
      setSocket(null);
      onClose?.();

      // Attempt reconnection
      if (shouldReconnect && reconnectAttemptsRef.current < reconnectAttempts) {
        reconnectAttemptsRef.current++;
        
        reconnectTimeoutRef.current = setTimeout(() => {
          connect();
        }, reconnectInterval);
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      onError?.(error);
    };

    setSocket(ws);
  }, [url, onOpen, onMessage, onClose, onError, shouldReconnect, reconnectAttempts, reconnectInterval]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    socket?.close();
  }, [socket]);

  const sendMessage = useCallback((message: any) => {
    if (socket?.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  }, [socket]);

  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  return {
    socket,
    connectionStatus,
    lastMessage,
    sendMessage,
    connect,
    disconnect,
  };
};
```

## API Error Handling

### Centralized Error Handling
```typescript
// ✅ Global error handling with accessibility
interface ApiErrorContext {
  endpoint: string;
  method: string;
  statusCode?: number;
  userMessage?: string;
}

class ApiErrorHandler {
  static handle(error: Error, context: ApiErrorContext) {
    const { endpoint, method, statusCode, userMessage } = context;
    
    // Log for developers
    console.error(`API Error [${method} ${endpoint}]:`, error);
    
    // Determine user-friendly message
    let message = userMessage || this.getDefaultMessage(statusCode);
    
    // Announce error to screen readers
    this.announceError(message);
    
    // Send to error tracking service
    this.trackError(error, context);
    
    return message;
  }

  private static getDefaultMessage(statusCode?: number): string {
    switch (statusCode) {
      case 400:
        return 'The request was invalid. Please check your input and try again.';
      case 401:
        return 'You need to log in to access this resource.';
      case 403:
        return 'You do not have permission to access this resource.';
      case 404:
        return 'The requested resource was not found.';
      case 429:
        return 'Too many requests. Please try again later.';
      case 500:
        return 'A server error occurred. Please try again later.';
      default:
        return 'An unexpected error occurred. Please try again.';
    }
  }

  private static announceError(message: string) {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'assertive');
    announcement.setAttribute('role', 'alert');
    announcement.className = 'sr-only';
    announcement.textContent = `Error: ${message}`;
    
    document.body.appendChild(announcement);
    
    setTimeout(() => {
      if (document.body.contains(announcement)) {
        document.body.removeChild(announcement);
      }
    }, 5000);
  }

  private static trackError(error: Error, context: ApiErrorContext) {
    // Send to error tracking service (Sentry, LogRocket, etc.)
    if (process.env.NODE_ENV === 'production') {
      // Example: Sentry.captureException(error, { contexts: { api: context } });
    }
  }
}

// Usage in components
const useApiErrorHandler = () => {
  const handleError = useCallback((error: Error, context: ApiErrorContext) => {
    return ApiErrorHandler.handle(error, context);
  }, []);

  return { handleError };
};
```

## Data Synchronization

### Optimistic Updates Pattern
```typescript
// ✅ Optimistic updates with rollback
export const useOptimisticUpdate = <T, U>(
  data: T[],
  updateFn: (item: T, updates: U) => Promise<T>,
  keyFn: (item: T) => string | number
) => {
  const [optimisticData, setOptimisticData] = useState(data);
  const [pendingUpdates, setPendingUpdates] = useState<Map<string | number, U>>(new Map());

  useEffect(() => {
    setOptimisticData(data);
  }, [data]);

  const updateItem = useCallback(async (itemId: string | number, updates: U) => {
    // Find the item to update
    const itemIndex = optimisticData.findIndex(item => keyFn(item) === itemId);
    if (itemIndex === -1) return;

    const originalItem = optimisticData[itemIndex];
    
    // Apply optimistic update
    const optimisticItem = { ...originalItem, ...updates };
    setOptimisticData(prev => 
      prev.map((item, index) => index === itemIndex ? optimisticItem : item)
    );
    
    // Track pending update
    setPendingUpdates(prev => new Map(prev).set(itemId, updates));

    try {
      // Attempt real update
      const updatedItem = await updateFn(originalItem, updates);
      
      // Apply real update
      setOptimisticData(prev => 
        prev.map((item, index) => index === itemIndex ? updatedItem : item)
      );
      
      // Remove from pending
      setPendingUpdates(prev => {
        const newMap = new Map(prev);
        newMap.delete(itemId);
        return newMap;
      });

      // Announce success
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.className = 'sr-only';
      announcement.textContent = 'Update saved successfully';
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 2000);

    } catch (error) {
      // Rollback optimistic update
      setOptimisticData(prev => 
        prev.map((item, index) => index === itemIndex ? originalItem : item)
      );
      
      // Remove from pending
      setPendingUpdates(prev => {
        const newMap = new Map(prev);
        newMap.delete(itemId);
        return newMap;
      });

      // Announce error
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'assertive');
      announcement.setAttribute('role', 'alert');
      announcement.className = 'sr-only';
      announcement.textContent = 'Update failed. Changes have been reverted.';
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 3000);

      throw error;
    }
  }, [optimisticData, updateFn, keyFn]);

  return {
    data: optimisticData,
    updateItem,
    pendingUpdates,
    hasPendingUpdates: pendingUpdates.size > 0,
  };
};
```

## When to Apply These Patterns

- **REST API Client**: When building applications with RESTful services
- **GraphQL Integration**: When using GraphQL for data fetching
- **WebSocket Hooks**: For real-time features like chat, notifications, live updates
- **Error Handling**: Always use centralized error handling for consistent UX
- **Optimistic Updates**: For actions that users expect immediate feedback (likes, comments, simple edits)
- **Data Fetching Hooks**: For any component that needs to fetch external data
