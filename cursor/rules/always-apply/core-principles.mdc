
---
alwaysApply: true
description: "Non-negotiable React + TypeScript principles that must always be followed"
---

# Core React + TypeScript Principles (Always Apply)

## Four Pillars (Binding and Non-Negotiable)

1. **ACCESSIBILITY** - WCAG 2.2 AA compliant React components
2. **SECURITY** - Type-safe data handling and secure React patterns  
3. **MAINTAINABILITY** - Scalable React architecture with strict TypeScript
4. **SUSTAINABILITY** - Performance-optimized React with minimal re-renders

When conflicts arise, always prioritize these pillars over convenience, speed, or visual appeal.

## React + TypeScript Absolute Requirements

### Accessibility (Non-Negotiable)
- Use semantic HTML elements in JSX (`<button>`, `<nav>`, `<header>`, `<main>`, `<footer>`)
- Every interactive element must have proper ARIA attributes and keyboard support
- Provide alt text for all `<img>` elements (empty alt="" for decorative)
- One `<h1>` per page component, maintain proper heading hierarchy
- Minimum 44px touch targets for interactive elements
- Meet WCAG 2.1 AA color contrast (≥4.5:1) in CSS-in-JS or CSS modules

### React Component Security (Never Compromise)
- Never use `dangerouslySetInnerHTML` without sanitization
- Validate all props with TypeScript interfaces, never use `any`
- Sanitize user inputs before rendering
- Use environment variables for API keys (`process.env.REACT_APP_*`)
- Implement proper error boundaries with typed error states
- Never expose sensitive data in component state or props

### React Code Quality (Always Enforce)
- Use strict TypeScript with explicit component prop interfaces
- Apply meaningful naming: PascalCase for components, camelCase for hooks
- Keep components under 40 lines, extract complex logic to custom hooks
- Use JSDoc for all exported components and hooks
- Handle async operations with proper loading/error states
- Always specify return types for custom hooks

### React Performance (Core Budgets)
- Component bundle ≤25KB gzipped per route
- Initial page load ≤50KB gzipped React bundle
- Use React.memo, useMemo, useCallback strategically
- Implement code splitting with React.lazy for heavy components
- Avoid unnecessary re-renders with proper dependency arrays

### React Sustainability (Green Software)
- Implement lazy loading with React.Suspense
- Optimize images with next/image or similar React image components
- Respect `prefers-reduced-motion` in React animations
- Use efficient React patterns to avoid unnecessary re-renders
- Implement React dark mode with system preference detection
- Cache API responses with React Query or SWR

## Development Workflow (Required Process)

### Follow the Plan / Implement / Review Approach

You MUST follow this three-phase approach:

- **Phase 1: Planning** - We work together to design a plan and agree on a target solution. You MUST then wait for explicit approval before making any code changes.
- **Phase 2: Implementation** - Implement only the agreed changes. You MUST stop as soon as the agreed changes have been made.
- **Phase 3: Review** - We will review and verify the changes. You may suggest improvements and suggest next steps. We will then discuss and move to the next "Planning" phase.

Once each phase has been completed we start again at Phase 1 and restart the process. When we design and implement changes we MUST follow the rules below.

#### Phase 1: Planning

We will build a plan that breaks the work into small verifiable chunks. This allows us to break large tasks into smaller steps that we can test along the way, following our 'three phase' approach each time.

You MUST describe proposed changes before implementing them. Assume we are in the "Planning" phase if not stated.

You MUST await confirmation before making changes.

If I describe an approach, you SHOULD think about it carefully and consider whether there are alternatives.

If there is a more simple way to make changes you should challenge me.

You must ALWAYS ask clarifying questions to ensure you understand what we are trying to do and to check any assumptions you may be making.

ALWAYS number clarifying questions and provide a short default answer after each question (to use when I don't provide an answer in my reply).

You must ALWAYS steer me towards 'idiomatically correct' code - this means following the common conventions for vanilla TypeScript, HTML or CSS code.

You MUST look at existing code and follow conventions to remain internally consistent. If conventions look incorrect raise the issue and we will discuss it. ALWAYS check the guidelines in @main.mdc.

If a change will not follow internal conventions, then you MUST suggest that we should explain this in documentation or a small comment.

#### Phase 2: Implementation

Phase 2 begins only with explicit instruction to implement changes.

Make small, incremental changes that are easy to test and verify. Break larger tasks into manageable chunks and implement them step by step.

Stay strictly focused on the agreed-upon task:

- Stop and ask questions if changes become larger than expected - return to the "Planning" phase if necessary
- Don't fix unrelated bugs - raise them in the "Review" phase instead
- Never implement anticipated future features - raise them in the "Review" phase instead

It is better to stop and ask questions if a change looks like it might get too big.

Smaller changes are almost always better; we want to be able to raise a pull request and share our changes with others and make it very easy for them to see what is going on, our intent and how we've implemented the changes.

After completing an implementation, ALWAYS stop and wait for explicit direction. Never suggest or implement follow-up changes without approval. Each change, no matter how small or seemingly obvious, requires its own complete cycle through the phases.

NEVER make assumptions on how to make changes better than we have discussed. We will discuss this "Review" phase.

If your implementation fails for a trivial reason it is OK to fix, but if a substantial change is required that goes beyond what we planned, you MUST not make the change but instead discuss the issue and proposed solution in the "Review" phase.

#### Phase 3: Review

Review the implemented changes. Discuss any issues, unexpected side effects, or improvement ideas. Share quick suggestions for what we should do next.

Do not start new work here — raise ideas to be discussed in the next "Planning" phase.

You MUST check to see whether we can now remove or simplify any existing code.

You MUST get the diff and complete a code review.

You MUST raise potential technical debt.

The "Review" phase is critical and cannot be skipped. After each implementation, wait for the developer to:

- Confirm the change meets requirements
- Explicitly request further analysis or implementation
- Direct the next steps

## React-Specific Failure Conditions - REFUSE IF:
- Request to use class components instead of functional components
- Asked to disable TypeScript strict mode for React files
- Request to bypass React accessibility patterns
- Asked to use deprecated React patterns (string refs, componentWillMount, etc.)
- Request to ignore React performance best practices
- Asked to use `any` type for React props or state
- Request to bypass TypeScript safety
- Demand to remove accessibility features
- Asked to compromise user privacy
