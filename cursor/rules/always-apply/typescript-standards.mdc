---
alwaysApply: true
description: "React + TypeScript strict standards that must always be followed"
---

# React + TypeScript Standards (Always Apply)

## React Component Type Safety

### Component Props Interfaces
```typescript
// ✅ Always define explicit props interfaces
interface ButtonProps {
  readonly children: React.ReactNode;
  readonly onClick?: () => void;
  readonly variant?: 'primary' | 'secondary' | 'danger';
  readonly disabled?: boolean;
  readonly loading?: boolean;
  readonly size?: 'small' | 'medium' | 'large';
  readonly ariaLabel?: string;
  readonly className?: string;
}

// ✅ Export component with proper typing
export const Button: React.FC<ButtonProps> = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  disabled = false,
  loading = false,
  size = 'medium',
  ariaLabel,
  className,
  ...restProps 
}) => {
  const buttonClasses = `btn btn--${variant} btn--${size} ${className || ''}`;
  
  return (
    <button
      onClick={onClick}
      disabled={disabled || loading}
      aria-label={ariaLabel}
      className={buttonClasses}
      type="button"
      {...restProps}
    >
      {loading ? <Spinner size="small" /> : children}
    </button>
  );
};
```

### React Hook Type Safety
```typescript
// ✅ Custom hooks with proper return types
interface UseApiState<T> {
  readonly data: T | null;
  readonly loading: boolean;
  readonly error: Error | null;
}

interface UseApiReturn<T> extends UseApiState<T> {
  readonly refetch: () => Promise<void>;
  readonly reset: () => void;
}

function useApi<T>(url: string): UseApiReturn<T> {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    loading: false,
    error: null,
  });
  
  const fetchData = useCallback(async (): Promise<void> => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data: T = await response.json();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error instanceof Error ? error : new Error(String(error))
      }));
    }
  }, [url]);
  
  const reset = useCallback((): void => {
    setState({ data: null, loading: false, error: null });
  }, []);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { ...state, refetch: fetchData, reset };
}
```

### React Event Handler Types
```typescript
// ✅ Proper event handler typing
interface FormProps {
  readonly onSubmit: (data: FormData) => Promise<void>;
  readonly onChange?: (field: string, value: string) => void;
  readonly onValidationError?: (errors: ValidationError[]) => void;
}

const ContactForm: React.FC<FormProps> = ({ onSubmit, onChange, onValidationError }) => {
  const handleSubmit = useCallback((event: React.FormEvent<HTMLFormElement>): void => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    onSubmit(formData);
  }, [onSubmit]);
  
  const handleInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = event.target;
    onChange?.(name, value);
  }, [onChange]);
  
  // Component implementation...
};
```

### React State Types with Discriminated Unions
```typescript
// ✅ Type-safe state management
type AsyncState<T> = 
  | { readonly status: 'idle' }
  | { readonly status: 'loading' }
  | { readonly status: 'success'; readonly data: T }
  | { readonly status: 'error'; readonly error: Error };

interface User {
  readonly id: string;
  readonly name: string;
  readonly email: string;
}

function useUserProfile(userId: string): AsyncState<User> {
  const [state, setState] = useState<AsyncState<User>>({ status: 'idle' });
  
  useEffect(() => {
    if (!userId) return;
    
    setState({ status: 'loading' });
    
    fetchUser(userId)
      .then((user: User) => setState({ status: 'success', data: user }))
      .catch((error: Error) => setState({ status: 'error', error }));
  }, [userId]);
  
  return state;
}

// ✅ Usage with type narrowing
const UserProfileComponent: React.FC<{ userId: string }> = ({ userId }) => {
  const userState = useUserProfile(userId);
  
  switch (userState.status) {
    case 'idle':
      return <div>Ready to load user...</div>;
    case 'loading':
      return <div role="status" aria-live="polite">Loading user...</div>;
    case 'success':
      return <div>Welcome, {userState.data.name}!</div>; // TypeScript knows data exists
    case 'error':
      return <div role="alert">Error: {userState.error.message}</div>; // TypeScript knows error exists
    default:
      // TypeScript ensures exhaustive checking
      const _exhaustive: never = userState;
      return _exhaustive;
  }
};
```

# TypeScript Standards (Always Apply)

## Strict Type Safety

### No Any Types
```typescript
// ❌ Never use any
function badFunction(data: any): any {
  return data.whatever;
}

// ✅ Use proper types
interface UserData {
  id: string;
  name: string;
  email: string;
}

function goodFunction(data: UserData): string {
  return data.name;
}
```

### Explicit Return Types
```typescript
// ❌ Implicit return type
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ✅ Explicit return type
function calculateTotal(items: PriceItem[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### Proper Error Handling
```typescript
// ❌ Throwing unknown types
function riskyOperation(): string {
  throw "Something went wrong";
}

// ✅ Proper error types
class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

function safeOperation(): string {
  throw new ValidationError("Invalid input", "email");
}
```

## Interface Design

### Comprehensive Interfaces
```typescript
// ✅ Well-defined interfaces
interface ApiResponse<T> {
  readonly data: T;
  readonly status: 'success' | 'error';
  readonly timestamp: Date;
  readonly errors?: readonly string[];
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  readonly pagination: {
    readonly page: number;
    readonly limit: number;
    readonly total: number;
    readonly hasNext: boolean;
  };
}
```

### Discriminated Unions
```typescript
// ✅ Use discriminated unions for state
type LoadingState<T> = 
  | { readonly status: 'idle' }
  | { readonly status: 'loading' }
  | { readonly status: 'success'; readonly data: T }
  | { readonly status: 'error'; readonly error: Error };

// ✅ Action types with discriminated unions
type UserAction = 
  | { readonly type: 'FETCH_START' }
  | { readonly type: 'FETCH_SUCCESS'; readonly payload: User }
  | { readonly type: 'FETCH_ERROR'; readonly error: string }
  | { readonly type: 'UPDATE_PROFILE'; readonly payload: Partial<User> };
```

## Generic Constraints

### Proper Generic Usage
```typescript
// ✅ Constrained generics
interface Repository<T extends { id: string }> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
  delete(id: string): Promise<void>;
}

// ✅ Generic utility types
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// ✅ Conditional types for advanced scenarios
type ApiEndpoint<T> = T extends { id: string } 
  ? `/api/${string}/${string}` 
  : `/api/${string}`;
```

## Utility Types Usage

### Required Utility Types
```typescript
// ✅ Use built-in utility types
interface CreateUserRequest extends Omit<User, 'id' | 'createdAt' | 'updatedAt'> {
  password: string;
}

interface UpdateUserRequest extends Partial<Pick<User, 'name' | 'email'>> {
  id: string;
}

// ✅ Custom utility types for common patterns
type WithTimestamps<T> = T & {
  readonly createdAt: Date;
  readonly updatedAt: Date;
};

type ApiEntity<T> = WithTimestamps<T & { readonly id: string }>;
```

## Type Guards

### Runtime Type Validation
```typescript
// ✅ Type guards for runtime safety
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'email' in obj &&
    isString((obj as any).id) &&
    isString((obj as any).name) &&
    isString((obj as any).email)
  );
}

// ✅ Using type guards
function processUserData(data: unknown): User | null {
  if (isUser(data)) {
    return data; // TypeScript knows this is User
  }
  return null;
}
```

## Readonly and Immutability

### Immutable Data Structures
```typescript
// ✅ Use readonly for immutability
interface ImmutableUser {
  readonly id: string;
  readonly name: string;
  readonly email: string;
  readonly preferences: readonly UserPreference[];
}

// ✅ Deep readonly for nested objects
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

type ImmutableConfig = DeepReadonly<AppConfig>;
```

## Function Signatures

### Proper Function Types
```typescript
// ✅ Clear function signatures
type EventHandler<T = Event> = (event: T) => void;
type AsyncOperation<T, E = Error> = () => Promise<Result<T, E>>;
type Validator<T> = (value: T) => ValidationResult;

// ✅ Function overloads when necessary
function createElement(tag: 'div'): HTMLDivElement;
function createElement(tag: 'span'): HTMLSpanElement;
function createElement(tag: string): HTMLElement;
function createElement(tag: string): HTMLElement {
  return document.createElement(tag);
}
```

## Namespace and Module Organization

### Module Structure
```typescript
// ✅ Proper export patterns
export type { User, CreateUserRequest, UpdateUserRequest };
export { createUser, updateUser, deleteUser };
export { UserService } from './UserService';

// ✅ Namespace for related types
export namespace Api {
  export interface Request<T = unknown> {
    readonly method: 'GET' | 'POST' | 'PUT' | 'DELETE';
    readonly url: string;
    readonly data?: T;
    readonly headers?: Record<string, string>;
  }

  export interface Response<T = unknown> {
    readonly status: number;
    readonly data: T;
    readonly headers: Record<string, string>;
  }
}
```

## React-Specific Forbidden Patterns

### Never Use These in React
```typescript
// ❌ NEVER: Class components (use functional components)
class BadComponent extends React.Component {
  render() { return <div />; }
}

// ❌ NEVER: any type for props
interface BadProps {
  data: any; // Use specific types
  onClick: any; // Use proper event handler types
}

// ❌ NEVER: Deprecated React patterns
const BadComponent = React.createClass({ /* ... */ });
this.refs.myRef; // Use useRef hook
componentWillMount() { /* ... */ }; // Use useEffect

// ❌ NEVER: Inline object/array literals in JSX
<Component style={{marginTop: 10}} items={[1,2,3]} />

// ❌ NEVER: Missing dependency arrays
useEffect(() => {
  fetchData(userId);
}); // Missing [userId] dependency

// ❌ NEVER: Mutating state directly
setState(prevState => {
  prevState.items.push(newItem); // Don't mutate
  return prevState;
});
```

### React Anti-Patterns to Avoid
```typescript
// ❌ NEVER: Using indices as keys
{items.map((item, index) => 
  <Item key={index} data={item} />
)}

// ✅ GOOD: Use stable, unique keys
{items.map(item => 
  <Item key={item.id} data={item} />
)}

// ❌ NEVER: Conditional hooks
if (condition) {
  const [state, setState] = useState();
}

// ✅ GOOD: Hooks at top level always
const [state, setState] = useState();
```

## General TypeScript Forbidden Patterns

### Never Use These
```typescript
// ❌ NEVER: any type
let bad: any = whatever;

// ❌ NEVER: Function type
let badCallback: Function = () => {};

// ❌ NEVER: Object type
let badObject: Object = {};

// ❌ NEVER: Non-null assertion without good reason
const user = getUser()!.name; // Only if you're 100% certain

// ❌ NEVER: Type assertions without validation
const data = response as User; // Unsafe without runtime check
```

## Required React + TypeScript Compiler Options

These must be enabled in `tsconfig.json` for React projects:
```json
{
  "compilerOptions": {
    // React-specific options
    "jsx": "react-jsx",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    
    // Strict type checking (required)
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    
    // Additional React safety
    "forceConsistentCasingInFileNames": true,
    "noPropertyAccessFromIndexSignature": true
  },
  "include": [
    "src",
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "build",
    "dist"
  ]
}
```

## Type Documentation

### TSDoc Standards
```typescript
/**
 * Processes user authentication with comprehensive error handling
 * 
 * @param credentials - User login credentials
 * @param options - Additional authentication options
 * @returns Promise resolving to authenticated user or rejection with specific error
 * 
 * @throws {ValidationError} When credentials are invalid
 * @throws {NetworkError} When authentication service is unavailable
 * 
 * @example
 * ```typescript
 * try {
 *   const user = await authenticateUser(
 *     { email: 'user@example.com', password: 'secure123' },
 *     { rememberMe: true }
 *   );
 *   console.log(`Welcome ${user.name}`);
 * } catch (error) {
 *   handleAuthError(error);
 * }
 * ```
 */
async function authenticateUser(
  credentials: LoginCredentials,
  options: AuthOptions = {}
 ): Promise<AuthenticatedUser> {
   // Implementation...
 }
 ```
