# Testing Rules (File-Specific)

## Test File Structure

### Naming and Organization
```typescript
// ✅ Good: Clear test file naming
// Button.test.tsx - Component tests
// useLocalStorage.test.ts - Hook tests  
// userService.spec.ts - Service tests
// integration.test.tsx - Integration tests

// ✅ Good: Test structure
describe('Button Component', () => {
  // Accessibility tests first
  describe('Accessibility', () => {
    it('should have no accessibility violations', async () => {
      const { container } = render(<Button>Test</Button>);
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it('should be keyboard accessible', async () => {
      const user = userEvent.setup();
      const handleClick = jest.fn();
      
      render(<Button onClick={handleClick}>Click me</Button>);
      
      await user.tab();
      expect(screen.getByRole('button')).toHaveFocus();
      
      await user.keyboard('{Enter}');
      expect(handleClick).toHaveBeenCalled();
    });
  });

  // Functionality tests
  describe('Functionality', () => {
    it('should render children correctly', () => {
      render(<Button>Test Button</Button>);
      expect(screen.getByRole('button')).toHaveTextContent('Test Button');
    });
  });

  // Edge cases and error scenarios
  describe('Edge Cases', () => {
    it('should handle disabled state', () => {
      render(<Button disabled>Disabled</Button>);
      expect(screen.getByRole('button')).toBeDisabled();
    });
  });
});
```

## Accessibility Testing (Required)

### Automated A11y Testing
```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';

// ✅ Always extend expect for accessibility
expect.extend(toHaveNoViolations);

describe('Accessibility Tests', () => {
  it('should have no accessibility violations', async () => {
    const { container } = render(<ComponentUnderTest />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('should support keyboard navigation', async () => {
    const user = userEvent.setup();
    render(<NavigableComponent />);
    
    // Test tab order
    await user.tab();
    expect(screen.getByRole('button', { name: /first/i })).toHaveFocus();
    
    await user.tab();
    expect(screen.getByRole('button', { name: /second/i })).toHaveFocus();
  });

  it('should announce changes to screen readers', async () => {
    const user = userEvent.setup();
    render(<DynamicComponent />);
    
    // Look for aria-live regions
    await user.click(screen.getByRole('button', { name: /update/i }));
    
    expect(screen.getByRole('status')).toHaveTextContent('Updated successfully');
  });

  it('should have proper focus management', async () => {
    const user = userEvent.setup();
    render(<ModalComponent />);
    
    // Open modal
    await user.click(screen.getByRole('button', { name: /open modal/i }));
    
    // Focus should be trapped in modal
    const modal = screen.getByRole('dialog');
    expect(modal).toHaveFocus();
    
    // Close modal
    await user.keyboard('{Escape}');
    
    // Focus should return to trigger
    expect(screen.getByRole('button', { name: /open modal/i })).toHaveFocus();
  });
});
```

### Screen Reader Testing Helpers
```typescript
// ✅ Helper functions for accessibility testing
const getAccessibilityTree = (container: HTMLElement) => {
  const tree = [];
  const walker = document.createTreeWalker(
    container,
    NodeFilter.SHOW_ELEMENT,
    {
      acceptNode: (node: Element) => {
        // Include elements with semantic meaning
        if (node.hasAttribute('role') || 
            node.hasAttribute('aria-label') ||
            node.hasAttribute('aria-labelledby') ||
            ['button', 'input', 'select', 'textarea', 'a'].includes(node.tagName.toLowerCase())) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    }
  );

  let node;
  while (node = walker.nextNode()) {
    tree.push({
      tagName: node.tagName,
      role: node.getAttribute('role'),
      ariaLabel: node.getAttribute('aria-label'),
      textContent: node.textContent?.trim(),
    });
  }
  
  return tree;
};

const testScreenReaderExperience = async (component: React.ReactElement) => {
  const { container } = render(component);
  const accessibilityTree = getAccessibilityTree(container);
  
  // Verify meaningful accessibility tree
  expect(accessibilityTree.length).toBeGreaterThan(0);
  
  // Check for proper labeling
  accessibilityTree.forEach(node => {
    if (['button', 'input'].includes(node.tagName.toLowerCase())) {
      expect(node.ariaLabel || node.textContent).toBeTruthy();
    }
  });
};
```

## Component Testing Patterns

### Comprehensive Component Testing
```typescript
describe('UserProfile Component', () => {
  const defaultProps = {
    user: {
      id: '1',
      name: 'John Doe',
      email: 'john@example.com',
      avatar: 'https://example.com/avatar.jpg'
    },
    onEdit: jest.fn(),
    onDelete: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ✅ Test all interactive states
  describe('Interactive States', () => {
    it('should handle edit action', async () => {
      const user = userEvent.setup();
      render(<UserProfile {...defaultProps} />);
      
      await user.click(screen.getByRole('button', { name: /edit profile/i }));
      
      expect(defaultProps.onEdit).toHaveBeenCalledWith(defaultProps.user);
    });

    it('should handle delete with confirmation', async () => {
      const user = userEvent.setup();
      render(<UserProfile {...defaultProps} />);
      
      await user.click(screen.getByRole('button', { name: /delete profile/i }));
      
      // Should show confirmation dialog
      expect(screen.getByRole('dialog')).toBeInTheDocument();
      
      await user.click(screen.getByRole('button', { name: /confirm delete/i }));
      
      expect(defaultProps.onDelete).toHaveBeenCalledWith(defaultProps.user.id);
    });
  });

  // ✅ Test error states
  describe('Error States', () => {
    it('should handle missing avatar gracefully', () => {
      const userWithoutAvatar = { ...defaultProps.user, avatar: undefined };
      
      render(<UserProfile {...defaultProps} user={userWithoutAvatar} />);
      
      // Should show default avatar or initials
      expect(screen.getByText('JD')).toBeInTheDocument(); // Initials fallback
    });

    it('should handle loading state', () => {
      render(<UserProfile {...defaultProps} isLoading />);
      
      expect(screen.getByRole('status', { name: /loading/i })).toBeInTheDocument();
      expect(screen.getByLabelText(/loading user profile/i)).toBeInTheDocument();
    });
  });

  // ✅ Test responsive behavior
  describe('Responsive Behavior', () => {
    it('should adapt to mobile viewport', () => {
      // Mock mobile viewport
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 375,
      });

      render(<UserProfile {...defaultProps} />);
      
      // Check for mobile-specific elements or layout
      expect(screen.getByTestId('mobile-layout')).toBeInTheDocument();
    });
  });
});
```

## Hook Testing Patterns

### Custom Hook Testing
```typescript
import { renderHook, act } from '@testing-library/react';

describe('useLocalStorage Hook', () => {
  const key = 'test-key';
  const initialValue = 'initial';

  beforeEach(() => {
    localStorage.clear();
  });

  // ✅ Test basic functionality
  it('should return initial value when localStorage is empty', () => {
    const { result } = renderHook(() => useLocalStorage(key, initialValue));
    
    expect(result.current[0]).toBe(initialValue);
  });

  it('should update localStorage when value changes', () => {
    const { result } = renderHook(() => useLocalStorage(key, initialValue));
    
    act(() => {
      result.current[1]('new value');
    });
    
    expect(result.current[0]).toBe('new value');
    expect(localStorage.getItem(key)).toBe('"new value"');
  });

  // ✅ Test error scenarios
  it('should handle localStorage errors gracefully', () => {
    // Mock localStorage to throw error
    const setItemSpy = jest.spyOn(Storage.prototype, 'setItem')
      .mockImplementation(() => {
        throw new Error('Storage quota exceeded');
      });

    const { result } = renderHook(() => useLocalStorage(key, initialValue));
    
    // Should not throw, should handle error gracefully
    act(() => {
      result.current[1]('new value');
    });
    
    // Should maintain current state
    expect(result.current[0]).toBe('new value');
    
    setItemSpy.mockRestore();
  });

  // ✅ Test cleanup
  it('should not cause memory leaks', () => {
    const { unmount } = renderHook(() => useLocalStorage(key, initialValue));
    
    // Unmount should not cause errors
    expect(() => unmount()).not.toThrow();
  });
});
```

## Integration Testing

### API Integration Tests
```typescript
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        id: req.params.id,
        name: 'John Doe',
        email: 'john@example.com'
      })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('User Profile Integration', () => {
  it('should load and display user data', async () => {
    render(<UserProfilePage userId="1" />);
    
    // Should show loading state
    expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();
    
    // Should load and display user data
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('should handle API errors gracefully', async () => {
    server.use(
      rest.get('/api/users/:id', (req, res, ctx) => {
        return res(ctx.status(500), ctx.json({ error: 'Server error' }));
      })
    );

    render(<UserProfilePage userId="1" />);
    
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent(/error loading user/i);
    });
  });
});
```

## Performance Testing

### Performance Benchmarks
```typescript
describe('Performance Tests', () => {
  it('should render large lists efficiently', () => {
    const items = Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
      description: `Description for item ${i}`
    }));

    const startTime = performance.now();
    
    render(<ItemList items={items} />);
    
    const endTime = performance.now();
    const renderTime = endTime - startTime;
    
    // Should render within reasonable time (adjust threshold as needed)
    expect(renderTime).toBeLessThan(100); // 100ms threshold
  });

  it('should not cause unnecessary re-renders', () => {
    const renderSpy = jest.fn();
    
    const TestComponent = React.memo(() => {
      renderSpy();
      return <div>Test</div>;
    });

    const { rerender } = render(<TestComponent />);
    
    expect(renderSpy).toHaveBeenCalledTimes(1);
    
    // Re-render with same props
    rerender(<TestComponent />);
    
    // Should not re-render with same props
    expect(renderSpy).toHaveBeenCalledTimes(1);
  });
});
```

## Test Utilities and Helpers

### Custom Testing Utilities
```typescript
// ✅ Custom render with providers
const customRender = (ui: React.ReactElement, options = {}) => {
  const AllProviders = ({ children }: { children: React.ReactNode }) => {
    return (
      <ErrorBoundary>
        <ThemeProvider>
          <I18nProvider>
            {children}
          </I18nProvider>
        </ThemeProvider>
      </ErrorBoundary>
    );
  };

  return render(ui, { wrapper: AllProviders, ...options });
};

// ✅ Accessibility testing helper
const testAccessibility = async (component: React.ReactElement) => {
  const { container } = customRender(component);
  
  const results = await axe(container);
  expect(results).toHaveNoViolations();
  
  return { container };
};

// ✅ Form testing helper
const fillForm = async (fields: Record<string, string>) => {
  const user = userEvent.setup();
  
  for (const [name, value] of Object.entries(fields)) {
    const field = screen.getByLabelText(new RegExp(name, 'i'));
    await user.clear(field);
    await user.type(field, value);
  }
};

// Export custom utilities
export { customRender as render, testAccessibility, fillForm };
```

## Test Coverage Requirements

### Coverage Thresholds
```javascript
// jest.config.js
module.exports = {
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{ts,tsx}',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
    // Stricter thresholds for critical components
    './src/components/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90,
    },
  },
};
```

## Required Test Categories

Every component/hook must have tests for:

1. **Accessibility** - No violations, keyboard navigation, screen reader support
2. **Functionality** - All features work as expected
3. **Error States** - Graceful error handling
4. **Edge Cases** - Boundary conditions and unusual inputs
5. **Performance** - No unnecessary re-renders or memory leaks
6. **Integration** - Works with other components/services
