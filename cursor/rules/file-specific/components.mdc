---
globs: ["**/*.tsx", "**/components/**/*.ts", "**/ui/**/*.tsx"]
description: "React component files with strict TypeScript patterns"
---

# React Component Rules (File-Specific)

## React + TypeScript Component Structure

### File Naming & Organization
- Use PascalCase for component files: `UserProfile.tsx`
- Use kebab-case for non-component files: `user-utils.ts`
- Co-locate related files: `Button.tsx`, `Button.module.css`, `Button.test.tsx`, `Button.stories.tsx`
- Index files should only re-export: `index.ts` with `export { Button } from './Button';`

### Component Declaration with TypeScript
```typescript
// ✅ Comprehensive interface with readonly properties
interface ButtonProps {
  readonly children: React.ReactNode;
  readonly onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  readonly onFocus?: (event: React.FocusEvent<HTMLButtonElement>) => void;
  readonly onBlur?: (event: React.FocusEvent<HTMLButtonElement>) => void;
  readonly variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
  readonly size?: 'sm' | 'md' | 'lg';
  readonly disabled?: boolean;
  readonly loading?: boolean;
  readonly type?: 'button' | 'submit' | 'reset';
  readonly ariaLabel?: string;
  readonly ariaDescribedBy?: string;
  readonly className?: string;
  readonly testId?: string;
}

// ✅ Component with proper TypeScript annotation and JSDoc
/**
 * Primary button component with full accessibility support
 * 
 * @param props - Button properties
 * @returns Accessible button element
 */
export const Button: React.FC<ButtonProps> = ({
  children,
  onClick,
  onFocus,
  onBlur,
  variant = 'primary',
  size = 'md',
  disabled = false,
  loading = false,
  type = 'button',
  ariaLabel,
  ariaDescribedBy,
  className,
  testId,
  ...restProps
}) => {
  const buttonClasses = cn(
    'btn',
    `btn--${variant}`,
    `btn--${size}`,
    {
      'btn--disabled': disabled,
      'btn--loading': loading,
    },
    className
  );

  return (
    <button
      type={type}
      onClick={disabled || loading ? undefined : onClick}
      onFocus={onFocus}
      onBlur={onBlur}
      disabled={disabled}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
      aria-busy={loading}
      className={buttonClasses}
      data-testid={testId}
      {...restProps}
    >
      {loading && <Spinner size="sm" aria-hidden="true" />}
      <span className={loading ? 'btn__text--hidden' : 'btn__text'}>
        {children}
      </span>
    </button>
  );
};

// ✅ Component display name for debugging
Button.displayName = 'Button';
```

## React Accessibility Requirements (Always)

### ARIA and Semantic HTML in JSX
```typescript
// ✅ Proper semantic structure with TypeScript
interface SearchInputProps {
  readonly onSearch: (query: string) => void;
  readonly placeholder?: string;
  readonly ariaLabel?: string;
  readonly loading?: boolean;
}

export const SearchInput: React.FC<SearchInputProps> = ({
  onSearch,
  placeholder = "Search...",
  ariaLabel = "Search input",
  loading = false
}) => {
  const [query, setQuery] = useState<string>('');
  const searchId = useId();
  const resultsId = useId();

  const handleSubmit = useCallback((event: React.FormEvent<HTMLFormElement>): void => {
    event.preventDefault();
    onSearch(query.trim());
  }, [onSearch, query]);

  const handleInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>): void => {
    setQuery(event.target.value);
  }, []);

  return (
    <form role="search" onSubmit={handleSubmit}>
      <label htmlFor={searchId} className="sr-only">
        {ariaLabel}
      </label>
      <div className="search-input">
        <input
          id={searchId}
          type="search"
          value={query}
          onChange={handleInputChange}
          placeholder={placeholder}
          aria-label={ariaLabel}
          aria-describedby={resultsId}
          aria-busy={loading}
          className="search-input__field"
          autoComplete="off"
        />
        <button
          type="submit"
          disabled={!query.trim() || loading}
          aria-label="Submit search"
          className="search-input__button"
        >
          {loading ? <Spinner size="sm" /> : <SearchIcon />}
        </button>
      </div>
      <div
        id={resultsId}
        role="status"
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      >
        {loading ? 'Searching...' : ''}
      </div>
    </form>
  );
};
```

### Focus Management and Keyboard Navigation
```typescript
// ✅ Modal with focus trap and keyboard support
interface ModalProps {
  readonly isOpen: boolean;
  readonly onClose: () => void;
  readonly children: React.ReactNode;
  readonly title: string;
  readonly closeOnEscape?: boolean;
  readonly closeOnBackdrop?: boolean;
}

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  children,
  title,
  closeOnEscape = true,
  closeOnBackdrop = true
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);
  const titleId = useId();

  // Store previous focus
  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement as HTMLElement;
    }
  }, [isOpen]);

  // Focus management
  useEffect(() => {
    if (isOpen && modalRef.current) {
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements[0] as HTMLElement;
      firstElement?.focus();
    } else if (!isOpen && previousFocusRef.current) {
      previousFocusRef.current.focus();
    }
  }, [isOpen]);

  // Keyboard event handling
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent): void => {
      if (!isOpen) return;

      if (event.key === 'Escape' && closeOnEscape) {
        onClose();
      }

      // Focus trap
      if (event.key === 'Tab' && modalRef.current) {
        const focusableElements = modalRef.current.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

        if (event.shiftKey && document.activeElement === firstElement) {
          event.preventDefault();
          lastElement?.focus();
        } else if (!event.shiftKey && document.activeElement === lastElement) {
          event.preventDefault();
          firstElement?.focus();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, closeOnEscape, onClose]);

  if (!isOpen) return null;

  return createPortal(
    <div
      className="modal-overlay"
      onClick={closeOnBackdrop ? onClose : undefined}
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
    >
      <div
        ref={modalRef}
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
      >
        <header className="modal-header">
          <h2 id={titleId} className="modal-title">
            {title}
          </h2>
          <button
            type="button"
            onClick={onClose}
            aria-label="Close modal"
            className="modal-close"
          >
            <CloseIcon />
          </button>
        </header>
        <main className="modal-body">
          {children}
        </main>
      </div>
    </div>,
    document.body
  );
};
```

## React Performance Patterns

### Memoization with TypeScript
```typescript
// ✅ Memoized component with typed props
interface ExpensiveListItemProps {
  readonly item: ListItem;
  readonly onSelect: (id: string) => void;
  readonly isSelected: boolean;
}

export const ExpensiveListItem = React.memo<ExpensiveListItemProps>(({
  item,
  onSelect,
  isSelected
}) => {
  const handleClick = useCallback((): void => {
    onSelect(item.id);
  }, [onSelect, item.id]);

  return (
    <div
      className={`list-item ${isSelected ? 'list-item--selected' : ''}`}
      onClick={handleClick}
      role="button"
      tabIndex={0}
      aria-pressed={isSelected}
    >
      {item.title}
    </div>
  );
});

ExpensiveListItem.displayName = 'ExpensiveListItem';

// ✅ Custom comparison function when needed
const areEqual = (
  prevProps: ExpensiveListItemProps,
  nextProps: ExpensiveListItemProps
): boolean => {
  return (
    prevProps.item.id === nextProps.item.id &&
    prevProps.item.title === nextProps.item.title &&
    prevProps.isSelected === nextProps.isSelected
  );
};

export const OptimizedListItem = React.memo(ExpensiveListItem, areEqual);
```

### Hook Optimization
```typescript
// ✅ Optimized custom hook with proper dependencies
interface UseDebounceOptions {
  readonly leading?: boolean;
  readonly trailing?: boolean;
}

function useDebounce<T extends readonly unknown[]>(
  fn: (...args: T) => void,
  delay: number,
  options: UseDebounceOptions = { trailing: true }
): (...args: T) => void {
  const { leading = false, trailing = true } = options;
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const leadingRef = useRef<boolean>(true);

  return useCallback(
    (...args: T): void => {
      const callNow = leading && leadingRef.current;

      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        leadingRef.current = true;
        if (trailing) {
          fn(...args);
        }
      }, delay);

      if (callNow) {
        leadingRef.current = false;
        fn(...args);
      }
    },
    [fn, delay, leading, trailing]
  );
}
```

## Error Handling in Components

### Error Boundaries with TypeScript
```typescript
interface ErrorBoundaryState {
  readonly hasError: boolean;
  readonly error: Error | null;
  readonly errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  readonly children: React.ReactNode;
  readonly fallback?: React.ComponentType<{ error: Error; reset: () => void }>;
  readonly onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    this.setState({ errorInfo });
    this.props.onError?.(error, errorInfo);
  }

  private handleReset = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  render(): React.ReactNode {
    if (this.state.hasError && this.state.error) {
      if (this.props.fallback) {
        const Fallback = this.props.fallback;
        return <Fallback error={this.state.error} reset={this.handleReset} />;
      }

      return (
        <div role="alert" className="error-boundary">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error.message}</pre>
            {this.state.errorInfo && (
              <pre>{this.state.errorInfo.componentStack}</pre>
            )}
          </details>
          <button onClick={this.handleReset}>Try again</button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Component Testing Requirements

### Testing Setup for TypeScript Components
```typescript
// ✅ Component test with accessibility checks
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';
import { Button } from './Button';

expect.extend(toHaveNoViolations);

describe('Button Component', () => {
  it('should be accessible', async () => {
    const { container } = render(
      <Button onClick={jest.fn()}>Click me</Button>
    );
    
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('should handle click events', async () => {
    const user = userEvent.setup();
    const handleClick = jest.fn();
    
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    await user.click(button);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should support keyboard navigation', async () => {
    const user = userEvent.setup();
    const handleClick = jest.fn();
    
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    
    await user.tab();
    expect(button).toHaveFocus();
    
    await user.keyboard('{Enter}');
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should show loading state', () => {
    render(
      <Button loading onClick={jest.fn()}>
        Submit
      </Button>
    );
    
    const button = screen.getByRole('button');
    expect(button).toHaveAttribute('aria-busy', 'true');
    expect(button).toBeDisabled();
  });
});
```

## Component Requirements Checklist

✅ **TypeScript Interface**: Explicit props interface with readonly properties  
✅ **Accessibility**: ARIA attributes, semantic HTML, keyboard support  
✅ **Error Handling**: Proper error boundaries and fallback states  
✅ **Performance**: Memoization when needed, optimized re-renders  
✅ **Testing**: Unit tests with accessibility checks  
✅ **Documentation**: JSDoc comments for all exported components  
✅ **Display Name**: Set for debugging React DevTools  
✅ **Type Safety**: No `any` types, proper event handler typing
