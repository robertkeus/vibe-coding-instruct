# Migration & Refactoring Procedures (Manual Only)

## React Component Migration

### Class to Function Component Migration
```typescript
// ✅ Step-by-step migration process

// 1. BEFORE: Class component
class UserProfile extends React.Component<UserProfileProps, UserProfileState> {
  constructor(props: UserProfileProps) {
    super(props);
    this.state = {
      isEditing: false,
      userData: null,
      loading: true,
    };
  }

  componentDidMount() {
    this.fetchUserData();
  }

  componentDidUpdate(prevProps: UserProfileProps) {
    if (prevProps.userId !== this.props.userId) {
      this.fetchUserData();
    }
  }

  fetchUserData = async () => {
    this.setState({ loading: true });
    try {
      const userData = await getUserById(this.props.userId);
      this.setState({ userData, loading: false });
    } catch (error) {
      this.setState({ loading: false });
    }
  };

  handleEdit = () => {
    this.setState({ isEditing: true });
  };

  render() {
    const { userData, loading, isEditing } = this.state;
    
    if (loading) return <LoadingSpinner />;
    
    return (
      <div>
        {/* Component JSX */}
      </div>
    );
  }
}

// 2. AFTER: Function component with hooks
const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [userData, setUserData] = useState<UserData | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchUserData = useCallback(async () => {
    setLoading(true);
    try {
      const data = await getUserById(userId);
      setUserData(data);
    } catch (error) {
      console.error('Failed to fetch user data:', error);
    } finally {
      setLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    fetchUserData();
  }, [fetchUserData]);

  const handleEdit = useCallback(() => {
    setIsEditing(true);
  }, []);

  if (loading) {
    return (
      <div aria-live="polite" aria-label="Loading user profile">
        <LoadingSpinner />
        <span className="sr-only">Loading user profile...</span>
      </div>
    );
  }

  return (
    <div>
      {/* Component JSX with improved accessibility */}
    </div>
  );
};

// 3. Migration checklist:
// ✅ Convert state to useState hooks
// ✅ Convert lifecycle methods to useEffect
// ✅ Add useCallback for event handlers
// ✅ Improve accessibility annotations
// ✅ Add proper TypeScript types
// ✅ Add error handling
// ✅ Test all functionality
```

### Legacy Context to Modern Context Migration
```typescript
// ✅ Context migration process

// 1. BEFORE: Legacy context
const ThemeContext = React.createContext();

class ThemeProvider extends React.Component {
  state = { theme: 'light' };
  
  setTheme = (theme) => {
    this.setState({ theme });
  };
  
  render() {
    return (
      <ThemeContext.Provider value={{
        theme: this.state.theme,
        setTheme: this.setTheme
      }}>
        {this.props.children}
      </ThemeContext.Provider>
    );
  }
}

// 2. AFTER: Modern context with TypeScript
interface ThemeContextType {
  theme: 'light' | 'dark' | 'auto';
  setTheme: (theme: 'light' | 'dark' | 'auto') => void;
  isDark: boolean;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark' | 'auto'>(() => {
    // Get from localStorage or system preference
    const saved = localStorage.getItem('theme') as 'light' | 'dark' | 'auto';
    return saved || 'auto';
  });

  const isDark = useMemo(() => {
    if (theme === 'auto') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    return theme === 'dark';
  }, [theme]);

  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
  }, [theme, isDark]);

  const value = useMemo(() => ({ theme, setTheme, isDark }), [theme, isDark]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

// 3. Migration steps:
// ✅ Add TypeScript interfaces
// ✅ Convert to function component
// ✅ Add proper state management
// ✅ Add localStorage persistence
// ✅ Add system preference detection
// ✅ Create custom hook
// ✅ Add error boundaries
```

## State Management Migration

### Redux to Zustand Migration
```typescript
// ✅ State management migration

// 1. BEFORE: Redux store
interface AppState {
  user: User | null;
  users: User[];
  loading: boolean;
  error: string | null;
}

const initialState: AppState = {
  user: null,
  users: [],
  loading: false,
  error: null,
};

const userReducer = (state = initialState, action: any) => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_USERS':
      return { ...state, users: action.payload };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    default:
      return state;
  }
};

// 2. AFTER: Zustand store
interface UserStore {
  // State
  user: User | null;
  users: User[];
  loading: boolean;
  error: string | null;
  
  // Actions
  setUser: (user: User | null) => void;
  setUsers: (users: User[]) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  
  // Async actions
  fetchUser: (id: string) => Promise<void>;
  fetchUsers: () => Promise<void>;
  createUser: (userData: CreateUserRequest) => Promise<void>;
}

export const useUserStore = create<UserStore>((set, get) => ({
  // State
  user: null,
  users: [],
  loading: false,
  error: null,
  
  // Sync actions
  setUser: (user) => set({ user }),
  setUsers: (users) => set({ users }),
  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),
  
  // Async actions
  fetchUser: async (id) => {
    set({ loading: true, error: null });
    try {
      const user = await userApi.getById(id);
      set({ user, loading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to fetch user',
        loading: false 
      });
    }
  },
  
  fetchUsers: async () => {
    set({ loading: true, error: null });
    try {
      const users = await userApi.getAll();
      set({ users, loading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to fetch users',
        loading: false 
      });
    }
  },
  
  createUser: async (userData) => {
    set({ loading: true, error: null });
    try {
      const newUser = await userApi.create(userData);
      set((state) => ({ 
        users: [newUser, ...state.users],
        loading: false 
      }));
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to create user',
        loading: false 
      });
    }
  },
}));

// 3. Usage migration:
// BEFORE: Redux
const Component = () => {
  const user = useSelector((state: AppState) => state.user);
  const dispatch = useDispatch();
  
  const handleFetch = () => {
    dispatch(fetchUser('123'));
  };
};

// AFTER: Zustand
const Component = () => {
  const { user, fetchUser } = useUserStore();
  
  const handleFetch = () => {
    fetchUser('123');
  };
};
```

## API Migration

### Fetch to React Query Migration
```typescript
// ✅ API fetching migration

// 1. BEFORE: Manual fetch with useState
const UsersList = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      try {
        const response = await fetch('/api/users');
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError('Failed to fetch users');
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};

// 2. AFTER: React Query
const UsersList = () => {
  const { 
    data: users = [], 
    isLoading, 
    error, 
    refetch 
  } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed to fetch users');
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 3,
  });

  if (isLoading) {
    return (
      <div aria-live="polite">
        <LoadingSpinner />
        <span className="sr-only">Loading users...</span>
      </div>
    );
  }

  if (error) {
    return (
      <div role="alert">
        <p>Failed to load users</p>
        <button onClick={() => refetch()}>Retry</button>
      </div>
    );
  }

  return (
    <ul role="list" aria-label="Users list">
      {users.map((user: User) => (
        <li key={user.id} role="listitem">{user.name}</li>
      ))}
    </ul>
  );
};

// 3. Benefits of migration:
// ✅ Automatic caching
// ✅ Background refetching
// ✅ Optimistic updates
// ✅ Error retry logic
// ✅ Loading states
// ✅ Better TypeScript support
```

## Accessibility Migration

### Adding ARIA Support to Existing Components
```typescript
// ✅ Accessibility enhancement migration

// 1. BEFORE: Basic component without accessibility
const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content">
        <div className="modal-header">
          <h2>{title}</h2>
          <button onClick={onClose}>×</button>
        </div>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>
  );
};

// 2. AFTER: Fully accessible modal
const Modal: React.FC<ModalProps> = ({ 
  isOpen, 
  onClose, 
  title, 
  children,
  ariaLabel,
  ariaDescribedBy 
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const previousFocus = useRef<HTMLElement | null>(null);
  const titleId = useId();
  const descriptionId = useId();

  // Focus management
  useEffect(() => {
    if (isOpen) {
      // Store current focus
      previousFocus.current = document.activeElement as HTMLElement;
      
      // Focus modal
      modalRef.current?.focus();
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
      
      // Escape key handler
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      
      document.addEventListener('keydown', handleEscape);
      
      return () => {
        document.removeEventListener('keydown', handleEscape);
        document.body.style.overflow = '';
        // Restore focus
        previousFocus.current?.focus();
      };
    }
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div 
      className="modal-overlay" 
      onClick={(e) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
      role="presentation"
    >
      <div
        ref={modalRef}
        className="modal-content"
        role="dialog"
        aria-modal="true"
        aria-labelledby={ariaLabel ? undefined : titleId}
        aria-label={ariaLabel}
        aria-describedby={ariaDescribedBy || descriptionId}
        tabIndex={-1}
      >
        <div className="modal-header">
          <h2 id={titleId}>{title}</h2>
          <button 
            onClick={onClose}
            aria-label="Close modal"
            className="modal-close"
          >
            <span aria-hidden="true">×</span>
          </button>
        </div>
        <div 
          id={descriptionId}
          className="modal-body"
        >
          {children}
        </div>
      </div>
    </div>
  );
};

// 3. Accessibility improvements added:
// ✅ Proper ARIA roles and properties
// ✅ Focus management
// ✅ Keyboard navigation (Escape key)
// ✅ Screen reader announcements
// ✅ Focus trapping
// ✅ Semantic heading structure
// ✅ Proper labeling
```

## Performance Migration

### Bundle Splitting and Lazy Loading
```typescript
// ✅ Performance optimization migration

// 1. BEFORE: All components imported eagerly
import { Routes, Route } from 'react-router-dom';
import HomePage from './pages/HomePage';
import ProfilePage from './pages/ProfilePage';
import SettingsPage from './pages/SettingsPage';
import AdminPage from './pages/AdminPage';

const App = () => {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/profile" element={<ProfilePage />} />
      <Route path="/settings" element={<SettingsPage />} />
      <Route path="/admin" element={<AdminPage />} />
    </Routes>
  );
};

// 2. AFTER: Lazy loaded with proper error boundaries
import { Routes, Route, Suspense } from 'react-router-dom';
import { ErrorBoundary } from './components/ErrorBoundary';
import { LoadingSpinner } from './components/LoadingSpinner';

// Lazy load page components
const HomePage = lazy(() => import('./pages/HomePage'));
const ProfilePage = lazy(() => import('./pages/ProfilePage'));
const SettingsPage = lazy(() => import('./pages/SettingsPage'));
const AdminPage = lazy(() => 
  import('./pages/AdminPage').then(module => ({
    default: module.AdminPage
  }))
);

// Loading component with accessibility
const PageLoader = ({ pageName }: { pageName: string }) => (
  <div className="page-loader" aria-live="polite">
    <LoadingSpinner />
    <span className="sr-only">Loading {pageName} page...</span>
  </div>
);

const App = () => {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <Routes>
        <Route 
          path="/" 
          element={
            <Suspense fallback={<PageLoader pageName="home" />}>
              <HomePage />
            </Suspense>
          } 
        />
        <Route 
          path="/profile" 
          element={
            <Suspense fallback={<PageLoader pageName="profile" />}>
              <ProfilePage />
            </Suspense>
          } 
        />
        <Route 
          path="/settings" 
          element={
            <Suspense fallback={<PageLoader pageName="settings" />}>
              <SettingsPage />
            </Suspense>
          } 
        />
        <Route 
          path="/admin" 
          element={
            <Suspense fallback={<PageLoader pageName="admin" />}>
              <AdminPage />
            </Suspense>
          } 
        />
      </Routes>
    </ErrorBoundary>
  );
};

// 3. Performance improvements:
// ✅ Route-based code splitting
// ✅ Reduced initial bundle size
// ✅ Faster page loads
// ✅ Accessible loading states
// ✅ Error boundaries for failed chunks
// ✅ Progressive loading
```

## Migration Checklist Template

### Complete Migration Checklist
```markdown
## Pre-Migration
- [ ] Identify all affected components/files
- [ ] Create comprehensive test coverage for existing functionality
- [ ] Document current behavior and edge cases
- [ ] Set up feature flags if needed for gradual rollout
- [ ] Backup current implementation

## During Migration
- [ ] Follow accessibility-first principles
- [ ] Maintain TypeScript strict mode compliance
- [ ] Add proper error handling
- [ ] Include loading states with screen reader support
- [ ] Add comprehensive testing for new implementation
- [ ] Performance test with realistic data

## Post-Migration
- [ ] Run full accessibility audit
- [ ] Performance testing and bundle size analysis
- [ ] Cross-browser testing
- [ ] Screen reader testing
- [ ] Update documentation
- [ ] Clean up old code and dependencies
- [ ] Monitor for issues in production

## Rollback Plan
- [ ] Document rollback procedures
- [ ] Keep old implementation available
- [ ] Monitor error rates and user feedback
- [ ] Have automated alerts for critical issues
```

## When to Use Manual Migration Procedures

- **Major React version upgrades** (16→17→18)
- **State management library changes** (Redux→Zustand, Context API)
- **Build tool migrations** (Webpack→Vite, CRA→Custom setup)
- **Testing framework updates** (Enzyme→Testing Library)
- **Accessibility compliance initiatives**
- **Performance optimization projects**
- **Legacy code modernization**
- **Type safety improvements** (JavaScript→TypeScript)
